
// Generated SDK - DO NOT EDIT MANUALLY
// This file is automatically generated from server API specifications


export class AnalyticsServerClient extends BaseClient {
  constructor(config: SDKConfig) {
    super(config, '/analytics-server');
  }

  /**
   * Track an analytics event
   */
  async trackEvent(data: any, options?: RequestOptions): Promise<APIResponse> {
    return this.request({
      method: 'POST',
      path: '/events',
      data,
      ...options
    });
  }

  /**
   * Track multiple analytics events
   */
  async trackEventsBatch(data: any, options?: RequestOptions): Promise<APIResponse> {
    return this.request({
      method: 'POST',
      path: '/events/batch',
      data,
      ...options
    });
  }

  /**
   * Get server health status
   */
  async getHealthStatus(options?: RequestOptions): Promise<APIResponse> {
    return this.request({
      method: 'GET',
      path: '/health',
      
      ...options
    });
  }
}


export class BiServerClient extends BaseClient {
  constructor(config: SDKConfig) {
    super(config, '/bi-server');
  }

  /**
   * Get available dashboards
   */
  async getDashboards(options?: RequestOptions): Promise<APIResponse> {
    return this.request({
      method: 'GET',
      path: '/dashboards',
      
      ...options
    });
  }

  /**
   * Get a specific report
   */
  async getReport(options?: RequestOptions): Promise<APIResponse> {
    return this.request({
      method: 'GET',
      path: '/reports/{reportId}',
      
      ...options
    });
  }
}


export class MonitoringServerClient extends BaseClient {
  constructor(config: SDKConfig) {
    super(config, '/monitoring-server');
  }

  /**
   * Report an application error
   */
  async reportError(data: any, options?: RequestOptions): Promise<APIResponse> {
    return this.request({
      method: 'POST',
      path: '/errors',
      data,
      ...options
    });
  }

  /**
   * Submit performance metrics
   */
  async submitMetrics(data: any, options?: RequestOptions): Promise<APIResponse> {
    return this.request({
      method: 'POST',
      path: '/metrics',
      data,
      ...options
    });
  }
}

export class NodashSDK {
  private config: SDKConfig;
  private clients: { [key: string]: any } = {};

  constructor(token: string, config: Partial<SDKConfig> = {}) {
    this.config = {
      token,
      baseUrl: 'https://api.nodash.ai',
      timeout: 30000,
      retries: 3,
      ...config
    };

    // Initialize server clients
    this.clients.analyticsServer = new AnalyticsServerClient(this.config);
    this.clients.biServer = new BiServerClient(this.config);
    this.clients.monitoringServer = new MonitoringServerClient(this.config);
  }

  // Server client getters
  get analyticsServer() { return this.clients.analyticsServer; }
  get biServer() { return this.clients.biServer; }
  get monitoringServer() { return this.clients.monitoringServer; }
}

export interface SDKConfig {
  token: string;
  baseUrl: string;
  timeout: number;
  retries: number;
}

export interface RequestOptions {
  params?: Record<string, any>;
  headers?: Record<string, string>;
  timeout?: number;
}

export interface APIResponse<T = any> {
  data: T;
  status: number;
  headers: Record<string, string>;
}

export interface APIError {
  message: string;
  code: string;
  status: number;
}

class BaseClient {
  constructor(protected config: SDKConfig, protected basePath: string) {}

  protected async request(options: {
    method: string;
    path: string;
    data?: any;
    params?: Record<string, any>;
    headers?: Record<string, string>;
  }): Promise<APIResponse> {
    const url = `${this.config.baseUrl}${this.basePath}${options.path}`;
    
    // This is a simplified implementation
    // In production, you'd use fetch/axios with proper error handling
    console.log(`Making ${options.method} request to ${url}`);
    
    return {
      data: { success: true },
      status: 200,
      headers: {}
    };
  }
}
