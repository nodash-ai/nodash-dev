import fs from 'fs-extra';
import path from 'path';
import chalk from 'chalk';

export interface GeneratorConfig {
  serversPath: string;
  sdkPath: string;
}

export interface ServerSpec {
  name: string;
  apiSpec: any;
}

export async function generateSDK(config: GeneratorConfig): Promise<void> {
  console.log(chalk.blue('üìã Discovering servers...'));
  const servers = await discoverServers(config.serversPath);

  console.log(chalk.blue('‚öôÔ∏è Generating SDK components...'));
  const sdkCode = generateSDKCode(servers);

  console.log(chalk.blue('üì¶ Writing SDK to local package...'));
  await writeSDKToPackage(config.sdkPath, sdkCode);
}

async function discoverServers(serversPath: string): Promise<ServerSpec[]> {
  if (!await fs.pathExists(serversPath)) {
    throw new Error(`Servers directory not found: ${serversPath}`);
  }

  const servers: ServerSpec[] = [];
  const entries = await fs.readdir(serversPath, { withFileTypes: true });
  
  for (const entry of entries) {
    if (entry.isDirectory()) {
      const serverPath = path.join(serversPath, entry.name);
      const specPath = path.join(serverPath, 'api-spec.json');
      
      if (await fs.pathExists(specPath)) {
        const apiSpec = await fs.readJson(specPath);
        servers.push({
          name: entry.name,
          apiSpec
        });
        
        console.log(chalk.green(`  ‚úì Found server: ${entry.name}`));
      }
    }
  }

  if (servers.length === 0) {
    throw new Error('No servers with API specifications found');
  }

  return servers;
}

function generateSDKCode(servers: ServerSpec[]): string {
  const clientClasses = servers.map(server => generateServerClient(server)).join('\n\n');
  
  return `
// Generated SDK - DO NOT EDIT MANUALLY
// This file is automatically generated from server API specifications

${clientClasses}

export class NodashSDK {
  private config: SDKConfig;
  private clients: { [key: string]: any } = {};

  constructor(token: string, config: Partial<SDKConfig> = {}) {
    this.config = {
      token,
      baseUrl: 'https://api.nodash.ai',
      timeout: 30000,
      retries: 3,
      ...config
    };

    // Initialize server clients
${servers.map(server => 
  `    this.clients.${toCamelCase(server.name)} = new ${toPascalCase(server.name)}Client(this.config);`
).join('\n')}
  }

  // Server client getters
${servers.map(server => 
  `  get ${toCamelCase(server.name)}() { return this.clients.${toCamelCase(server.name)}; }`
).join('\n')}
}

export interface SDKConfig {
  token: string;
  baseUrl: string;
  timeout: number;
  retries: number;
}

export interface RequestOptions {
  params?: Record<string, any>;
  headers?: Record<string, string>;
  timeout?: number;
}

export interface APIResponse<T = any> {
  data: T;
  status: number;
  headers: Record<string, string>;
}

export interface APIError {
  message: string;
  code: string;
  status: number;
}

class BaseClient {
  constructor(protected config: SDKConfig, protected basePath: string) {}

  protected async request(options: {
    method: string;
    path: string;
    data?: any;
    params?: Record<string, any>;
    headers?: Record<string, string>;
  }): Promise<APIResponse> {
    const url = \`\${this.config.baseUrl}\${this.basePath}\${options.path}\`;
    
    // This is a simplified implementation
    // In production, you'd use fetch/axios with proper error handling
    console.log(\`Making \${options.method} request to \${url}\`);
    
    return {
      data: { success: true },
      status: 200,
      headers: {}
    };
  }
}
`;
}

function generateServerClient(server: ServerSpec): string {
  const className = `${toPascalCase(server.name)}Client`;
  const methods = extractMethods(server.apiSpec);
  
  return `
export class ${className} extends BaseClient {
  constructor(config: SDKConfig) {
    super(config, '/${server.name}');
  }

${methods.map(method => generateMethod(method)).join('\n\n')}
}`;
}

function extractMethods(apiSpec: any): Array<{
  name: string;
  path: string;
  method: string;
  description: string;
  hasBody: boolean;
}> {
  const methods: any[] = [];
  
  if (apiSpec.paths) {
    Object.entries(apiSpec.paths).forEach(([path, pathItem]: [string, any]) => {
      if (pathItem && typeof pathItem === 'object') {
        Object.entries(pathItem).forEach(([method, operation]: [string, any]) => {
          if (operation && operation.operationId) {
            methods.push({
              name: toCamelCase(operation.operationId),
              path,
              method: method.toUpperCase(),
              description: operation.summary || operation.description || '',
              hasBody: ['POST', 'PUT', 'PATCH'].includes(method.toUpperCase())
            });
          }
        });
      }
    });
  }
  
  return methods;
}

function generateMethod(method: any): string {
  return `  /**
   * ${method.description}
   */
  async ${method.name}(${method.hasBody ? 'data: any, ' : ''}options?: RequestOptions): Promise<APIResponse> {
    return this.request({
      method: '${method.method}',
      path: '${method.path}',
      ${method.hasBody ? 'data,' : ''}
      ...options
    });
  }`;
}

async function writeSDKToPackage(sdkPackagePath: string, sdkCode: string): Promise<void> {
  // Ensure the SDK src directory exists
  const srcPath = path.join(sdkPackagePath, 'src');
  await fs.ensureDir(srcPath);
  
  // Write the generated SDK
  await fs.writeFile(path.join(srcPath, 'index.ts'), sdkCode);
  
  console.log(chalk.green('  ‚úì Updated local package SDK'));
}

function toPascalCase(str: string): string {
  return str.replace(/(^|[-_])([a-z])/g, (_, __, char) => char.toUpperCase());
}

function toCamelCase(str: string): string {
  const pascal = toPascalCase(str);
  return pascal.charAt(0).toLowerCase() + pascal.slice(1);
}
